{
  "id": "bd405da0-1c45-42c7-8b7b-b12be21dc5cb",
  "title": "Primary Constructors in C# 12+ - Modern Pattern",
  "details": "Primary Constructors in C# 12+ (.NET 8+)\n\nWHAT ARE PRIMARY CONSTRUCTORS?\nPrimary constructors allow you to declare constructor parameters directly in the class declaration, eliminating the need for explicit constructor methods and field assignments for simple scenarios.\n\nSYNTAX:\nInstead of:\n```csharp\npublic class UserService\n{\n    private readonly ILogger<UserService> _logger;\n    private readonly IUserRepository _repository;\n    \n    public UserService(ILogger<UserService> logger, IUserRepository repository)\n    {\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        _repository = repository ?? throw new ArgumentNullException(nameof(repository));\n    }\n}\n```\n\nYou can write:\n```csharp\npublic class UserService(ILogger<UserService> logger, IUserRepository repository)\n{\n    private readonly ILogger<UserService> _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    private readonly IUserRepository _repository = repository ?? throw new ArgumentNullException(nameof(repository));\n    \n    // Or even simpler, just use the parameters directly:\n    public void DoSomething() => logger.LogInformation(\"Doing something\");\n}\n```\n\nBENEFITS:\n1. Reduces boilerplate code for simple dependency injection\n2. Makes class declaration more concise\n3. Parameters are automatically captured and available throughout the class\n4. Still allows explicit field assignment when needed\n\nWHEN TO USE:\n✅ Simple dependency injection scenarios\n✅ Classes with few constructor parameters\n✅ When you don't need complex constructor logic\n✅ Data classes and services with straightforward initialization\n\nWHEN NOT TO USE:\n❌ Complex constructor logic (validation, initialization)\n❌ Multiple constructors needed\n❌ When constructor parameters need transformation\n❌ Classes with many dependencies (readability suffers)\n\nBEST PRACTICES:\n- Keep parameter lists short (3-5 parameters max)\n- Use meaningful parameter names\n- Consider explicit field assignment for complex scenarios\n- Combine with records for data classes\n\nEXAMPLES IN DEPENDENCY INJECTION:\n```csharp\n// Service with DI\npublic class EmailService(IEmailProvider provider, ILogger<EmailService> logger)\n{\n    public async Task SendAsync(string to, string subject, string body)\n    {\n        logger.LogInformation(\"Sending email to {To}\", to);\n        await provider.SendAsync(to, subject, body);\n    }\n}\n\n// Record with primary constructor\npublic record User(int Id, string Name, string Email);\n\n// Class with validation\npublic class OrderProcessor(IOrderRepository repository, ILogger<OrderProcessor> logger)\n{\n    private readonly IOrderRepository _repository = repository ?? throw new ArgumentNullException(nameof(repository));\n    \n    public async Task ProcessAsync(Order order) => await _repository.SaveAsync(order);\n}\n```",
  "category": "coding_standards",
  "dateCreated": "2025-06-05T02:18:34.894Z",
  "dateUpdated": "2025-06-05T02:18:34.894Z"
}