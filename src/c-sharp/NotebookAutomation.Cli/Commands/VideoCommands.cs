using System.CommandLine;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using NotebookAutomation.Core.Configuration;
using NotebookAutomation.Core.Tools.VideoProcessing;
using NotebookAutomation.Cli.Utilities;

namespace NotebookAutomation.Cli.Commands
{    /// <summary>
     /// Provides CLI commands for processing video files and generating markdown notes.
     /// 
     /// This class registers the 'video-notes' command for processing video files to extract 
     /// metadata, generate markdown notes with appropriate frontmatter, and optionally 
     /// include references to the original video file.
     /// </summary>
     /// <remarks>
     /// The video processing functionality utilizes the <see cref="VideoNoteProcessingEntrypoint"/>
     /// from the Core library to handle the actual processing of video files. The supported 
     /// video formats are defined in the application configuration and typically include
     /// MP4, MOV, AVI, MKV, WEBM, and others.
     /// </remarks>
    internal class VideoCommands
    {        /// <summary>
             /// Registers the 'video-notes' command with the root command.
             /// </summary>
             /// <param name="rootCommand">The root command to add video processing commands to.</param>
             /// <param name="configOption">The global config file option.</param>
             /// <param name="debugOption">The global debug option.</param>
             /// <param name="verboseOption">The global verbose output option.</param>
             /// <param name="dryRunOption">The global dry run option to simulate actions without making changes.</param>
        public void Register(RootCommand rootCommand, Option<string> configOption, Option<bool> debugOption, Option<bool> verboseOption, Option<bool> dryRunOption)
        {
            var inputOption = new Option<string?>(
                aliases: ["--input", "-i"],
                description: "Path to the input video file or directory (will auto-detect if it's a file or folder)")
            {
                IsRequired = true
            }; var outputOption = new Option<string>(
                aliases: ["--overwrite-output-dir", "-o"],
                description: "Override the default output directory (normally uses notebook_vault_fullpath_root from config)"); var resourcesRootOption = new Option<string?>(
                aliases: ["--onedrive-fullpath-root"],
                description: "Override OneDrive fullpath root directory"
            ); var noSummaryOption = new Option<bool>(
                aliases: ["--no-summary"],
                description: "Skip summary generation (summary is generated by default)"
            );
            var retryFailedOption = new Option<bool>(
                aliases: ["--retry-failed"],
                description: "Retry only failed files from previous run"
            );
            var forceOption = new Option<bool>(
                aliases: ["--force"],
                description: "Overwrite existing notes"
            );
            var timeoutOption = new Option<int?>(
                aliases: ["--timeout"],
                description: "Set API request timeout (seconds)"
            );
            var refreshAuthOption = new Option<bool>(
                aliases: ["--refresh-auth"],
                description: "Force refresh Microsoft Graph API authentication"
            ); var noShareLinksOption = new Option<bool>(
                aliases: ["--no-share-links"],
                description: "Skip OneDrive share link creation (links are created by default)"
            );

            var videoCommand = new Command("video-notes", "Video notes and metadata commands"); videoCommand.AddOption(inputOption);
            videoCommand.AddOption(outputOption);
            videoCommand.AddOption(resourcesRootOption);
            videoCommand.AddOption(noSummaryOption);
            videoCommand.AddOption(retryFailedOption);
            videoCommand.AddOption(forceOption); videoCommand.AddOption(timeoutOption);
            videoCommand.AddOption(refreshAuthOption);
            videoCommand.AddOption(noShareLinksOption);

            videoCommand.SetHandler(async context =>
            {
                string? input = context.ParseResult.GetValueForOption(inputOption);
                string? overrideOutputDir = context.ParseResult.GetValueForOption(outputOption);
                string? config = context.ParseResult.GetValueForOption(configOption);
                bool debug = context.ParseResult.GetValueForOption(debugOption);
                bool verbose = context.ParseResult.GetValueForOption(verboseOption);
                bool dryRun = context.ParseResult.GetValueForOption(dryRunOption);
                string? resourcesRoot = context.ParseResult.GetValueForOption(resourcesRootOption);
                bool noSummary = context.ParseResult.GetValueForOption(noSummaryOption);
                bool retryFailed = context.ParseResult.GetValueForOption(retryFailedOption); bool force = context.ParseResult.GetValueForOption(forceOption);
                int? timeout = context.ParseResult.GetValueForOption(timeoutOption);
                bool refreshAuth = context.ParseResult.GetValueForOption(refreshAuthOption);
                bool noShareLinks = context.ParseResult.GetValueForOption(noShareLinksOption);

                // TODO: Wire these options into the video processing logic as needed

                // Initialize dependency injection if needed
                if (config != null)
                {
                    if (!File.Exists(config))
                    {
                        AnsiConsoleHelper.WriteError($"Configuration file not found: {config}");
                        return;
                    }
                    Program.SetupDependencyInjection(config, debug);
                }

                // Use DI container to get services
                var serviceProvider = Program.ServiceProvider;
                var loggerFactory = serviceProvider.GetRequiredService<ILoggerFactory>();
                var logger = loggerFactory.CreateLogger("VideoCommands");
                var loggingService = serviceProvider.GetRequiredService<LoggingService>();

                var appConfig = serviceProvider.GetRequiredService<AppConfig>();
                var batchProcessor = serviceProvider.GetRequiredService<VideoNoteBatchProcessor>();

                // Output the configured settings before processing
                AnsiConsoleHelper.WriteInfo($"Configured settings:");
                AnsiConsoleHelper.WriteInfo($"  Debug: {debug}");
                AnsiConsoleHelper.WriteInfo($"  Config file: {config}");
                AnsiConsoleHelper.WriteInfo($"  Input: {input}");
                AnsiConsoleHelper.WriteInfo($"  Output directory: {overrideOutputDir ?? "(default)"}");
                AnsiConsoleHelper.WriteInfo($"  Dry run: {dryRun}");
                AnsiConsoleHelper.WriteInfo($"  Skip summary: {noSummary}");
                AnsiConsoleHelper.WriteInfo($"  Force overwrite: {force}");
                AnsiConsoleHelper.WriteInfo($"  Retry failed: {retryFailed}");
                AnsiConsoleHelper.WriteInfo($"  Timeout: {(timeout.HasValue ? timeout.Value.ToString() : "(default)")}");
                AnsiConsoleHelper.WriteInfo($"  OneDrive fullpath root: {resourcesRoot ?? "(default)"}");
                AnsiConsoleHelper.WriteInfo($"  Skip share links: {noShareLinks}");
                AnsiConsoleHelper.WriteInfo($"  Video extensions: {string.Join(", ", appConfig.VideoExtensions ?? new List<string>())}");
                AnsiConsoleHelper.WriteInfo($"  AI Model: {appConfig.AiService?.Model}");
                AnsiConsoleHelper.WriteInfo($"  AI Endpoint: {appConfig.AiService?.Endpoint}");
                AnsiConsoleHelper.WriteInfo($"  Logging Dir: {appConfig.Paths?.LoggingDir}");

                // Validate OpenAI config before proceeding
                if (!ConfigValidation.RequireOpenAi(appConfig))
                {
                    logger.LogError("OpenAI configuration is missing or incomplete. Exiting.");
                    return;
                }
                // Get video extensions from config
                var videoExtensions = appConfig.VideoExtensions ?? new List<string> { ".mp4", ".mov", ".avi", ".mkv", ".webm" };

                // Get OpenAI API key from environment or config
                string? openAiApiKey = Environment.GetEnvironmentVariable(AIServiceConfig.AiApiKeyEnvVar);
                if (string.IsNullOrWhiteSpace(openAiApiKey) && appConfig.AiService != null)
                {
                    openAiApiKey = appConfig.AiService.GetApiKey();
                }
                // Process videos
                // Verify that we have an input source
                if (string.IsNullOrWhiteSpace(input))
                {
                    logger.LogError("Input source is required. Use --input/-i to specify a video file or folder.");
                    return;
                }

                // Auto-detect if input is a file or folder
                bool isFile = File.Exists(input);
                bool isDirectory = Directory.Exists(input);

                if (!isFile && !isDirectory)
                {
                    logger.LogError("Input path does not exist or is not accessible: {Path}", input);
                    return;
                }

                logger.LogInformation("Processing {Type}: {Path}",
                    isFile ? "file" : "directory",
                    input);                // Log where output will be written
                logger.LogInformation("Output will be written to: {OutputPath}",
                    overrideOutputDir ?? appConfig.Paths?.NotebookVaultFullpathRoot ?? "Generated");

                var result = await batchProcessor.ProcessVideosAsync(
                    // Use the input from command line
                    input,
                    overrideOutputDir ?? appConfig.Paths?.NotebookVaultFullpathRoot ?? "Generated",
                    videoExtensions,
                    openAiApiKey,
                    dryRun,
                    noSummary,
                    force,
                    retryFailed,
                    timeout,
                    resourcesRoot,
                    appConfig,
                    noShareLinks);

                logger.LogInformation("Video processing completed. Success: {Processed}, Failed: {Failed}", result.Processed, result.Failed);
                if (!string.IsNullOrWhiteSpace(result.Summary))
                {
                    AnsiConsoleHelper.WriteInfo(result.Summary);
                }
            });

            rootCommand.AddCommand(videoCommand);
        }
    }
}
