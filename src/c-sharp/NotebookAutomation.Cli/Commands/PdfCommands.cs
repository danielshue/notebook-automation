// Licensed under the MIT License. See LICENSE file in the project root for full license information.
[assembly: InternalsVisibleTo("DynamicProxyGenAssembly2")]

namespace NotebookAutomation.Cli.Commands;

/// <summary>
/// Provides CLI commands for processing PDF files and converting them to markdown notes within the Notebook Automation CLI.
/// </summary>
/// <remarks>
/// <para>
/// The <see cref="PdfCommands"/> class is responsible for registering and handling the <c>pdf-notes</c> command,
/// which enables users to process PDF files or directories of PDFs, extract their text content, and generate
/// markdown notes with appropriate frontmatter and metadata. The command supports advanced features such as:
/// </para>
/// <list type="bullet">
///   <item>AI-generated summaries using configurable providers (OpenAI, Azure, Foundry, etc.)</item>
///   <item>OneDrive integration for resource path resolution and share link creation</item>
///   <item>Customizable output directories and vault root overrides</item>
///   <item>Image extraction from PDFs</item>
///   <item>Retrying failed files, force overwrite, and dry-run simulation</item>
///   <item>Comprehensive logging and progress reporting</item>
/// </list>
/// <para>
/// The class leverages dependency injection for configuration, logging, and service resolution, and ensures
/// robust cross-platform path handling by combining OneDrive root and resource base paths as needed.
/// </para>
/// <para>
/// <b>Usage Example:</b>
/// <code language="shell">
/// na.exe pdf-notes --input "C:\Users\me\OneDrive\Resources\MyFile.pdf" --overwrite-output-dir "C:\Notes"
/// </code>
/// </para>
/// <para>
/// <b>Example: Registering the command</b>
/// <code language="csharp">
/// var pdfCommands = new PdfCommands(logger);
/// pdfCommands.Register(rootCommand, configOption, debugOption, verboseOption, dryRunOption);
/// </code>
/// </para>
/// <para>
/// For details on path resolution and configuration, see <see cref="PathUtils.ResolveInputPath(string, string?, string?)"/>.
/// </para>
/// </remarks>
internal class PdfCommands
{
    private readonly ILogger<PdfCommands> logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="PdfCommands"/> class.
    /// </summary>
    /// <param name="logger">The logger instance for logging information and errors.</param>
    public PdfCommands(ILogger<PdfCommands> logger)
    {
        this.logger = logger ?? throw new ArgumentNullException(nameof(logger));
        this.logger.LogDebug("PDF command initialized");
    }

    /// <summary>
    /// Registers the 'pdf-notes' command with the root command.
    /// </summary>
    /// <param name="rootCommand">The root command to add PDF processing commands to.</param>
    /// <param name="configOption">The global config file option.</param>
    /// <param name="debugOption">The global debug option.</param>
    /// <param name="verboseOption">The global verbose output option.</param>
    /// <param name="dryRunOption">The global dry run option to simulate actions without making changes.</param>
    public void Register(
        RootCommand rootCommand,
        Option<string> configOption,
        Option<bool> debugOption,
        Option<bool> verboseOption,
        Option<bool> dryRunOption)
    {
        ArgumentNullException.ThrowIfNull(rootCommand);
        ArgumentNullException.ThrowIfNull(configOption);
        ArgumentNullException.ThrowIfNull(debugOption);
        ArgumentNullException.ThrowIfNull(verboseOption);
        ArgumentNullException.ThrowIfNull(dryRunOption);

        var inputOption = new Option<string?>(
            aliases: ["--input", "-i"],
            description: "Path to the input PDF file or directory (will auto-detect if it's a file or folder)")
        {
            IsRequired = true,
        };
        var outputOption = new Option<string>(
            aliases: ["--overwrite-output-dir", "-o"],
            description: "Override the default output directory (normally uses notebook_vault_fullpath_root from config)");

        var vaultRootOverrideOption = new Option<string?>(
            aliases: ["--override-vault-root"],
            description: "Specify the explicit vault root path (overrides the config)");

        var resourcesRootOption = new Option<string?>(
            aliases: ["--onedrive-fullpath-root"],
            description: "Override OneDrive fullpath root directory");

        var noSummaryOption = new Option<bool>(
            aliases: ["--no-summary"],
            description: "Skip summary generation (summary is generated by default)");

        var retryFailedOption = new Option<bool>(
            aliases: ["--retry-failed"],
            description: "Retry only failed files from previous run");

        var forceOption = new Option<bool>(
            aliases: ["--force"],
            description: "Overwrite existing notes");

        var timeoutOption = new Option<int?>(
            aliases: ["--timeout"],
            description: "Set API request timeout (seconds)");

        var refreshAuthOption = new Option<bool>(
            aliases: ["--refresh-auth"],
            description: "Force refresh Microsoft Graph API authentication"); var noShareLinksOption = new Option<bool>(
            aliases: ["--no-share-links"],
            description: "Skip OneDrive share link creation (links are created by default)");

        var extractImagesOption = new Option<bool>(
            aliases: ["--extract-images"],
            description: "Extract images from PDFs and include them in generated text and markdown files"); var pdfCommand = new Command("pdf-notes", "PDF notes and metadata commands");
        pdfCommand.AddOption(inputOption);
        pdfCommand.AddOption(outputOption);
        pdfCommand.AddOption(vaultRootOverrideOption);
        pdfCommand.AddOption(resourcesRootOption);
        pdfCommand.AddOption(noSummaryOption);
        pdfCommand.AddOption(retryFailedOption);
        pdfCommand.AddOption(forceOption);
        pdfCommand.AddOption(timeoutOption);
        pdfCommand.AddOption(refreshAuthOption);
        pdfCommand.AddOption(noShareLinksOption);
        pdfCommand.AddOption(extractImagesOption);
        pdfCommand.SetHandler(async context =>
        {
            string? input = context.ParseResult.GetValueForOption(inputOption);
            string? overrideOutputDir = context.ParseResult.GetValueForOption(outputOption);
            string? vaultRootOverride = context.ParseResult.GetValueForOption(vaultRootOverrideOption);
            string? config = context.ParseResult.GetValueForOption(configOption);
            bool debug = context.ParseResult.GetValueForOption(debugOption);
            bool verbose = context.ParseResult.GetValueForOption(verboseOption);
            bool dryRun = context.ParseResult.GetValueForOption(dryRunOption);
            string? resourcesRoot = context.ParseResult.GetValueForOption(resourcesRootOption);
            bool noSummary = context.ParseResult.GetValueForOption(noSummaryOption);
            bool retryFailed = context.ParseResult.GetValueForOption(retryFailedOption);
            bool force = context.ParseResult.GetValueForOption(forceOption); int? timeout = context.ParseResult.GetValueForOption(timeoutOption);
            bool refreshAuth = context.ParseResult.GetValueForOption(refreshAuthOption);
            bool noShareLinks = context.ParseResult.GetValueForOption(noShareLinksOption);
            bool extractImages = context.ParseResult.GetValueForOption(extractImagesOption);

            // Print usage/help if required argument is missing
            if (string.IsNullOrEmpty(input))
            {
                AnsiConsoleHelper.WriteUsage(
                    "Usage: na.exe pdf-notes --input <file|dir> [options]",
                    pdfCommand.Description ?? string.Empty,
                    string.Join("\n", pdfCommand.Options.Select(option => $"  {string.Join(", ", option.Aliases)}\t{option.Description}")));
                return;
            }

            // Initialize dependency injection if needed
            if (config != null)
            {
                if (!File.Exists(config))
                {
                    AnsiConsoleHelper.WriteError($"Configuration file not found: {config}");
                    return;
                }

                Program.SetupDependencyInjection(config, debug);
            } // Use DI container to get services and create scoped context for vault root override

            var serviceProvider = Program.ServiceProvider;
            using var scope = serviceProvider.CreateScope();
            var scopedServices = scope.ServiceProvider;

            var loggerFactory = scopedServices.GetRequiredService<ILoggerFactory>();
            var logger = loggerFactory.CreateLogger("PdfCommands");
            var loggingService = scopedServices.GetRequiredService<LoggingService>();
            var appConfig = scopedServices.GetRequiredService<AppConfig>();            // Determine effective output directory for vault root context
            string effectiveOutputDir = overrideOutputDir ?? appConfig.Paths?.NotebookVaultFullpathRoot ?? "Generated";
            effectiveOutputDir = Path.GetFullPath(effectiveOutputDir);

            // Set up vault root override in scoped context
            var vaultRootContext = scopedServices.GetRequiredService<VaultRootContextService>();

            // Use explicit vault root override if provided, otherwise use effective output directory
            string finalVaultRoot = vaultRootOverride ?? effectiveOutputDir;
            vaultRootContext.VaultRootOverride = finalVaultRoot;
            logger.LogInformation($"Using vault root override for metadata hierarchy: {finalVaultRoot}");

            var batchProcessor = scopedServices.GetRequiredService<PdfNoteBatchProcessor>();

            // Handle refresh auth flag - set force refresh on OneDriveService if requested
            if (refreshAuth)
            {
                try
                {
                    var oneDriveService = scopedServices.GetService<IOneDriveService>();
                    if (oneDriveService != null)
                    {
                        oneDriveService.SetForceRefresh(true);
                        AnsiConsoleHelper.WriteInfo("Force refresh authentication enabled for OneDrive");
                    }
                    else
                    {
                        logger.LogWarning("OneDrive service not available - --refresh-auth flag ignored");
                    }
                }
                catch (Exception ex)
                {
                    ExceptionHandler.HandleException(ex, "Failed to set force refresh on OneDrive service");
                }
            }
            // Determine effective resources root (prioritize command line over config)
            string? effectiveResourcesRoot = resourcesRoot;
            if (string.IsNullOrWhiteSpace(effectiveResourcesRoot) && appConfig?.Paths != null)
            {
                effectiveResourcesRoot = appConfig.Paths.OnedriveFullpathRoot;
            }

            // Resolve input path - if it's relative, prepend with OneDrive root
            string resolvedInput = PathUtils.ResolveInputPath(
                input,
                effectiveResourcesRoot,
                appConfig?.Paths?.OnedriveResourcesBasepath
            );
            logger.LogDebug($"Input path resolution: '{input}' -> '{resolvedInput}' (OneDrive root: {effectiveResourcesRoot ?? "(none)"})");

            // Build the full local resources path for path calculations
            string? localResourcesPathForBatchProcessor = null;

            // Configure OneDriveService with vault roots if available
            if (!string.IsNullOrWhiteSpace(effectiveResourcesRoot) && appConfig?.Paths != null)
            {
                try
                {
                    var oneDriveService = scopedServices.GetService<IOneDriveService>();
                    if (oneDriveService != null && !string.IsNullOrWhiteSpace(appConfig.Paths.OnedriveResourcesBasepath))
                    {
                        // Build the local resources path by combining OneDrive sync root with resources subpath
                        var localResourcesPath = Path.Combine(
                            effectiveResourcesRoot,
                            appConfig.Paths.OnedriveResourcesBasepath.TrimStart('/', '\\'));
                        localResourcesPath = Path.GetFullPath(localResourcesPath);

                        // Store this for batch processor to use for path calculations
                        localResourcesPathForBatchProcessor = localResourcesPath;

                        // Configure vault roots: local resources folder -> OneDrive resources path
                        oneDriveService.ConfigureVaultRoots(localResourcesPath, appConfig.Paths.OnedriveResourcesBasepath);
                        logger.LogInformation($"Configured OneDrive vault roots - Local: {localResourcesPath}, OneDrive: {appConfig.Paths.OnedriveResourcesBasepath}");
                    }
                }
                catch (Exception ex)
                {
                    ExceptionHandler.HandleException(ex, "Failed to configure OneDrive vault roots");
                }
            }

            // Output the configured settings before processing (only in debug or verbose mode)
            if (debug || verbose)
            {
                AnsiConsoleHelper.WriteInfo($"Configured settings:");
                AnsiConsoleHelper.WriteInfo($"  Debug: {debug}");
                AnsiConsoleHelper.WriteInfo($"  Config file: {config}");
                AnsiConsoleHelper.WriteInfo($"  Input: {input}");
                AnsiConsoleHelper.WriteInfo($"  Output directory: {overrideOutputDir ?? "(default)"}");
                AnsiConsoleHelper.WriteInfo($"  Dry run: {dryRun}");
                AnsiConsoleHelper.WriteInfo($"  Skip summary: {noSummary}");
                AnsiConsoleHelper.WriteInfo($"  Force overwrite: {force}");
                AnsiConsoleHelper.WriteInfo($"  Retry failed: {retryFailed}");
                AnsiConsoleHelper.WriteInfo($"  Timeout: {(timeout.HasValue ? timeout.Value.ToString() : "(default)")}");
                AnsiConsoleHelper.WriteInfo($"  OneDrive fullpath root: {effectiveResourcesRoot ?? "(not configured)"}");
                AnsiConsoleHelper.WriteInfo($"  Config OneDrive root: {appConfig?.Paths?.OnedriveFullpathRoot ?? "(not set)"}");
                AnsiConsoleHelper.WriteInfo($"  Skip share links: {noShareLinks}");
                AnsiConsoleHelper.WriteInfo($"  PDF extensions: {string.Join(", ", appConfig?.PdfExtensions ?? [".pdf"])}");

                // Display more detailed AI service configuration
                AnsiConsoleHelper.WriteInfo($"  AI Provider: {appConfig?.AiService?.Provider ?? "openai"}");

                string selectedModel = "(not set)";
                string selectedEndpoint = "(not set)";

                switch (appConfig?.AiService?.Provider?.ToLowerInvariant())
                {
                    case "azure":
                        selectedModel = appConfig?.AiService?.Azure?.Model ?? "(not set)";
                        selectedEndpoint = appConfig?.AiService?.Azure?.Endpoint ?? "(not set)";
                        AnsiConsoleHelper.WriteInfo($"  AI Model: {selectedModel}");
                        AnsiConsoleHelper.WriteInfo($"  AI Deployment: {appConfig?.AiService?.Azure?.Deployment ?? "(not set)"}");
                        AnsiConsoleHelper.WriteInfo($"  AI Endpoint: {selectedEndpoint}");
                        break;

                    case "foundry":
                        selectedModel = appConfig?.AiService?.Foundry?.Model ?? "(not set)";
                        selectedEndpoint = appConfig?.AiService?.Foundry?.Endpoint ?? "(not set)";
                        AnsiConsoleHelper.WriteInfo($"  AI Model: {selectedModel}");
                        AnsiConsoleHelper.WriteInfo($"  AI Endpoint: {selectedEndpoint}");
                        break;

                    case "openai":
                    default:
                        selectedModel = appConfig?.AiService?.OpenAI?.Model ?? "(not set)";
                        selectedEndpoint = appConfig?.AiService?.OpenAI?.Endpoint ?? "https://api.openai.com/v1/chat/completions";
                        AnsiConsoleHelper.WriteInfo($"  AI Model: {selectedModel}");
                        AnsiConsoleHelper.WriteInfo($"  AI Endpoint: {selectedEndpoint}");
                        break;
                }

                // Display API key status (without revealing the key)
                string? apiKey = appConfig?.AiService?.GetApiKey();
                AnsiConsoleHelper.WriteInfo($"  API Key: {(string.IsNullOrEmpty(apiKey) ? "Not configured" : "Configured")}"); AnsiConsoleHelper.WriteInfo($"  Logging Dir: {appConfig?.Paths?.LoggingDir}");
            }

            // Validate AI config before proceeding
            if (appConfig == null || !ConfigValidation.RequireOpenAi(appConfig))
            {
                logger.LogError("AI configuration is missing or incomplete. Exiting.");
                return;
            }

            // Get PDF extensions from config
            var pdfExtensions = appConfig.PdfExtensions ?? [".pdf"];

            // Get AI API key from environment or config
            string? openAiApiKey = appConfig.AiService?.GetApiKey();

            // Process PDFs            // Verify that we have an input source
            if (string.IsNullOrWhiteSpace(input))
            {
                logger.LogError("Input source is required. Use --input/-i to specify a PDF file or folder.");
                return;
            }

            // Auto-detect if input is a file or folder using resolved path
            bool isFile = File.Exists(resolvedInput);
            bool isDirectory = Directory.Exists(resolvedInput);

            if (!isFile && !isDirectory)
            {
                logger.LogError($"Input path does not exist or is not accessible: {resolvedInput} (original: {input})");
                return;
            }

            logger.LogInformation(
                "Processing {Type}: {Path}",
                isFile ? "file" : "directory",
                resolvedInput); logger.LogInformation($"Output will be written to: {overrideOutputDir ?? appConfig.Paths?.NotebookVaultFullpathRoot ?? "Generated"}");

            // Override image extraction setting from CLI if specified
            bool originalExtractImages = appConfig.PdfExtractImages;
            if (extractImages != appConfig.PdfExtractImages)
            {
                appConfig.PdfExtractImages = extractImages;
                logger.LogInformation($"Overriding PDF image extraction setting from CLI: {extractImages}");
            }

            try
            {
                // Use the newer Spectre.Console status display with live updates
                var result = await AnsiConsoleHelper.WithStatusAsync(
                    async (updateStatus) =>
                    {
                        // Hook up progress events to update the status
                        batchProcessor.ProcessingProgressChanged += (sender, e) =>
                        {
                            // Escape any markup to avoid Spectre.Console parsing issues
                            string safeStatus = e.Status.Replace("[", "[[").Replace("]", "]]");

                            // The status already contains file count information, so we don't need to add it
                            updateStatus(safeStatus);
                        }; return await batchProcessor.ProcessPdfsAsync(
                            resolvedInput,
                            effectiveOutputDir,
                            pdfExtensions,
                            openAiApiKey,
                            dryRun,
                            noSummary,
                            force,
                            retryFailed,
                            timeout,
                            localResourcesPathForBatchProcessor,
                            appConfig).ConfigureAwait(false);
                    },
                    $"Processing PDF files from {(isFile ? "file" : "directory")}: {resolvedInput}").ConfigureAwait(false); logger.LogInformation($"PDF processing completed. Success: {result.Processed}, Failed: {result.Failed}");
                if (!string.IsNullOrWhiteSpace(result.Summary))
                {
                    AnsiConsoleHelper.WriteInfo(result.Summary);
                }
            }
            catch (Exception ex)
            {
                // No need to stop spinner manually, WithStatusAsync handles this
                ExceptionHandler.HandleException(ex, "Error processing PDF files");
            }
            finally
            {
                // Restore original image extraction setting
                if (extractImages != originalExtractImages)
                {
                    appConfig.PdfExtractImages = originalExtractImages;
                    logger.LogDebug($"Restored original PDF image extraction setting: {originalExtractImages}");
                }
            }
        });

        rootCommand.AddCommand(pdfCommand);
    }
}
